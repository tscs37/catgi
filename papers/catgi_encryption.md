# Catgi Encryption Backend

The Catgi Encryption Backend permanently alters how files
are accessed, it is incompatible with existing files and
existing data cannot be simply transfered into it.

It uses Ed25519, Polycha20 and Blake2b for key exchange, encryption
and authentication.

Encryption and Decryption happen Client Side, the server only sees
non-sensitive data and measures are taken to ensure that
the clients can verify the authenticity of the data they decrypt.

It should be extensible and support hardware-based de/encryption using
devices like Trezor, Nitrokey or Yubikey.

Additionally, the encryption backend provides a backwards compatible
encrypted backend that uses only a simple shared key, consisting of a key,
nonce and HMAC.

## Encrypted File Storage

Files are split into four parts;

* Encrypted File
* Sensitive Metadata
* Non-Sensitive Metadata
* Key File

### Key Exchange Structure

When uploading a file, the uploader becomes the Encryptor.

The client generates two ephemeral keypairs or alternatively generates
one ephemeral keypair and asks for a remote public key.

The first keypair is the Encryptor Key.

The second keypair is the Decryptor Key and may be generated using
a key derivation mechanism or by supplying a public key only. The private
key is only required for decryption.

The client may specify additional secondary keypairs.

For encryption the client generates a random starting nonce and a
random key for the Polycha construct.

For each secondary keypair the client will combine the public key with it's
private key, generate a HMAC and encrypt the random key, HMAC key and nonce.
The result is the "decryptor challenge data", DCD in short. The public key
that can decrypt the DCD is used as a key to the list in form of a map.

The public key of the primary set signs this list of secondary keypairs.

The server will accept updates to the DCD only from the original primary
keypair.

#### Primary Keypair Master

A Primary Keypair Master can be specified.

If the PKM is specified, the client must include the PKM public key
and a sign the primary keypair with this master key.

The server will accept updates from any new primary key if it is signed
by the same PKM, allowing users to reuse a identity if they want.

#### Decrypting

To decrypt the client receives the Key File from the server, containing
a list of decryptor challenge data sets.

The client needs to obtain a secondary keyset, which it then looks up
in the DCD map.

If no entry in the DCD matches, it requires to get a different secondary keyset.

If it matches, the client decrypts the DCD and verifies it using the
HMAC key. If the HMAC is ok, the client can decrypt the file.

To avoid side-channel attacks, the client should begin downloading
the encrypted file while searching for the DCD data, as downloading
only when a valid DCD is found might give an attacker an idea which
of many DCD keys is the used one.

### Key File

The structure of the key file is as follows:

```json
{
	"pfp": "<primary public key>",
	"pkm": "<primary keypair master>", // optional
	"kms": "<primary keypair master signature>", // optional
	"dcd": {
		"<public key>": "<dcd data>",
		"<public key>": "<dcd data>"
	},
	"nkf": "<new keyfile link>"
}
```

#### Key File Updates

The server will allow updates to the Key File if the original keypair
is reused or using a Primary Keypair Master, if specified.

To prevent the client from having to recreating DCD data, Catgi uses
the NKF key.

A client is required to follow all NKF links until all DCD data has been
retrieved. This reduces side-channel attacks which could reveal which DCD
belongs to a client.

A client should attempt to find it's public key in the key files in the order
they were retrieved.

### Split Metadata

To avoid leaking sensitive metadata, the metadata is split across
two files, a non-sensitive and a sensitive file.

The sensitive file must be encrypted by the client with the same keys
as the actual file data.

To avoid leaking metadata updates in the future, the following metadata
is defined as non-sensitive:

* Flake
* Creation Date
* Deletion Date
* Options

All other metadata in the non-sensitive file must be ignored in favor
of metadata in the sensitive file.

## Simple Resting Encryption

Simple Resting Encryption uses a predefined key and Polycha20+Blake2b
for en- and decryption.

When uploading the key is send to the server which performs the encryption
and returns a link that contains the cipher key, starting nonce and HMAC key.

The encrypted data is authenticated with EtM, the HMAC key is generated by
the server.

If SRE is used without a predefined key, the server generates a key.

## Implementation Status & Notes

SRE is simpler to maintain, however the frontend needs some modifications
for it to work.

EFS is more complex and requires clientside code in addition of some
frontend changes.

For either to work, backends need to be able to specify frontend behaviour
or atleast retrieve contextual data from the frontend to obtain the parameters
and modify the return URLs.

SRE is given priority over EFS.
